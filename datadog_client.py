"""
Datadog API Client
Handles communication with Datadog API for notebook operations
"""

import requests
import json
from typing import Dict, Any, Optional, List
import logging

logger = logging.getLogger(__name__)


class DatadogClient:
    def __init__(self, api_key: str, app_key: str, base_url: str = "https://api.datadoghq.com"):
        self.api_key = api_key
        self.app_key = app_key
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'DD-API-KEY': self.api_key,
            'DD-APPLICATION-KEY': self.app_key,
            'Content-Type': 'application/json'
        })
    
    def create_notebook(self, notebook_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a notebook in Datadog
        
        Args:
            notebook_data: The notebook JSON structure
            
        Returns:
            Response from Datadog API
        """
        url = f"{self.base_url}/api/v1/notebooks"
        
        try:
            # Remove any read-only fields that shouldn't be in creation request
            clean_data = self._clean_notebook_data_for_creation(notebook_data)
            
            response = self.session.post(url, json=clean_data)
            response.raise_for_status()
            
            result = response.json()
            logger.info(f"Successfully created notebook: {result.get('data', {}).get('id', 'Unknown ID')}")
            return result
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to create notebook: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_details = e.response.json()
                    logger.error(f"API Error Details: {error_details}")
                    return {"error": error_details, "status_code": e.response.status_code}
                except:
                    logger.error(f"Response content: {e.response.text}")
                    return {"error": e.response.text, "status_code": e.response.status_code}
            return {"error": str(e), "status_code": None}
    
    def _clean_notebook_data_for_creation(self, notebook_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Clean notebook data by removing read-only fields for creation
        """
        clean_data = json.loads(json.dumps(notebook_data))  # Deep copy
        
        # Remove read-only fields
        attrs = clean_data.get("data", {}).get("attributes", {})
        
        # Remove fields that are set by the API
        read_only_fields = ["id", "created", "modified", "deleted", "author"]
        for field in read_only_fields:
            attrs.pop(field, None)
        
        # Remove id from data level as well
        clean_data.get("data", {}).pop("id", None)
        
        # Clean up cells - remove IDs as they're generated by API
        cells = attrs.get("cells", [])
        for cell in cells:
            cell.pop("id", None)
        
        return clean_data
    
    def get_notebook(self, notebook_id: str) -> Dict[str, Any]:
        """
        Get a notebook by ID
        
        Args:
            notebook_id: The notebook ID
            
        Returns:
            Notebook data or error information
        """
        url = f"{self.base_url}/api/v1/notebooks/{notebook_id}"
        
        try:
            response = self.session.get(url)
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get notebook {notebook_id}: {str(e)}")
            return {"error": str(e), "status_code": getattr(e.response, 'status_code', None)}
    
    def list_notebooks(self, author_handle: Optional[str] = None, exclude_author_handle: Optional[str] = None,
                      start: int = 0, count: int = 5, sort_field: str = "modified", 
                      sort_dir: str = "desc") -> Dict[str, Any]:
        """
        List notebooks
        
        Args:
            author_handle: Filter by author handle
            exclude_author_handle: Exclude notebooks by author handle
            start: Starting index
            count: Number of notebooks to return
            sort_field: Field to sort by
            sort_dir: Sort direction (asc/desc)
            
        Returns:
            List of notebooks or error information
        """
        url = f"{self.base_url}/api/v1/notebooks"
        
        params = {
            "start": start,
            "count": count,
            "sort_field": sort_field,
            "sort_dir": sort_dir
        }
        
        if author_handle:
            params["author_handle"] = author_handle
        if exclude_author_handle:
            params["exclude_author_handle"] = exclude_author_handle
        
        try:
            response = self.session.get(url, params=params)
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to list notebooks: {str(e)}")
            return {"error": str(e), "status_code": getattr(e.response, 'status_code', None)}
    
    def update_notebook(self, notebook_id: str, notebook_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Update a notebook
        
        Args:
            notebook_id: The notebook ID
            notebook_data: The updated notebook data
            
        Returns:
            Updated notebook data or error information
        """
        url = f"{self.base_url}/api/v1/notebooks/{notebook_id}"
        
        try:
            clean_data = self._clean_notebook_data_for_creation(notebook_data)
            response = self.session.put(url, json=clean_data)
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to update notebook {notebook_id}: {str(e)}")
            return {"error": str(e), "status_code": getattr(e.response, 'status_code', None)}
    
    def delete_notebook(self, notebook_id: str) -> Dict[str, Any]:
        """
        Delete a notebook
        
        Args:
            notebook_id: The notebook ID
            
        Returns:
            Success status or error information
        """
        url = f"{self.base_url}/api/v1/notebooks/{notebook_id}"
        
        try:
            response = self.session.delete(url)
            response.raise_for_status()
            return {"success": True, "status_code": response.status_code}
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to delete notebook {notebook_id}: {str(e)}")
            return {"error": str(e), "status_code": getattr(e.response, 'status_code', None)}
    
    def test_connection(self) -> Dict[str, Any]:
        """
        Test the connection to Datadog API
        
        Returns:
            Connection status
        """
        try:
            # Try to list notebooks with a minimal request
            result = self.list_notebooks(count=1)
            if "error" not in result:
                return {"status": "connected", "message": "Successfully connected to Datadog API"}
            else:
                return {"status": "error", "message": f"Connection failed: {result['error']}"}
                
        except Exception as e:
            return {"status": "error", "message": f"Connection test failed: {str(e)}"}
    
    def validate_notebook_structure(self, notebook_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate notebook structure before creation
        
        Args:
            notebook_data: The notebook JSON structure
            
        Returns:
            Validation result
        """
        errors = []
        warnings = []
        
        try:
            # Check top-level structure
            if "data" not in notebook_data:
                errors.append("Missing 'data' field in notebook structure")
                return {"valid": False, "errors": errors, "warnings": warnings}
            
            data = notebook_data["data"]
            
            # Check data type
            if data.get("type") != "notebooks":
                errors.append("Data type must be 'notebooks'")
            
            # Check attributes
            if "attributes" not in data:
                errors.append("Missing 'attributes' field in data")
                return {"valid": False, "errors": errors, "warnings": warnings}
            
            attrs = data["attributes"]
            
            # Check required fields
            required_fields = ["name", "cells"]
            for field in required_fields:
                if field not in attrs:
                    errors.append(f"Missing required field: {field}")
            
            # Check cells structure
            if "cells" in attrs:
                cells = attrs["cells"]
                if not isinstance(cells, list):
                    errors.append("Cells must be a list")
                else:
                    for i, cell in enumerate(cells):
                        if "type" not in cell:
                            errors.append(f"Cell {i} missing 'type' field")
                        if "attributes" not in cell:
                            errors.append(f"Cell {i} missing 'attributes' field")
                        elif "definition" not in cell["attributes"]:
                            errors.append(f"Cell {i} missing 'definition' in attributes")
            
            # Check optional but recommended fields
            if "time" not in attrs:
                warnings.append("No time range specified, will use default")
            
            if "metadata" not in attrs:
                warnings.append("No metadata specified, will use defaults")
            
            return {
                "valid": len(errors) == 0,
                "errors": errors,
                "warnings": warnings
            }
            
        except Exception as e:
            return {
                "valid": False,
                "errors": [f"Validation error: {str(e)}"],
                "warnings": warnings
            } 